<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">

  <title>Erlang &amp; Elixir</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="css/reveal.min.css">
  <link rel="stylesheet" href="css/theme/night.css" id="theme">
  <link rel="stylesheet" href="css/theme/zenburn.css">
  <link rel="stylesheet" href="css/highlight/zenburn.css">
  <style>
  .reveal strong {
    color: #e7ad52;
  }
  .reveal pre code {
    max-height: 800px;
  }
  
  .text-note {
    text-align: left;
    font-size: 85%;

  }
  .side-by-side code {
    font-size: 90%;
  }

  .side-by-side .left,
  .side-by-side .right {
    float: left;
    padding-right: 1%;
    width: 49%;
    margin: 0px auto;
  }

  .side-by-side {
    clear: both;
  }

  .clearfix {
    clear: both;
  }

  .reveal pre code {
    line-height: 1.5em;
  }
  </style>
</head>

<body>

  <div class="reveal">

    <div class="slides">

      <!-- Intro -->
      <section>
        
        <section>
          <h2>Erlang &amp; Elixir</h2>
          <p>by Bartosz Ptaszynski</p>
        </section>

        <section>
          <h2>Who am I?</h2>
          <p>Polyglot programmer and programming languages tourist</p>
          <p><a href="http://twitter.com/foobarto">@foobarto</a> | <a href="mailto:bart@yazzgoth.com">bart@yazzgoth.com</a></p>
        </section>
      </section>
<!--
      <section>
        <section>
          <h2>Before we start - Installation</h2>
        </section>

        <section>
          <h3>Install Erlang</h3>
          <p>Ubuntu</p>
          <pre><code class='bash'>
sudo apt-get install erlang
          </code></pre>
          <p>OS X</p>
          <pre><code class='bash'>
brew install erlang
          </code></pre>
        </section>
        <section>
          <h3>Install Elixir</h3>
          <p>Ubuntu</p>
          <pre><code class='bash'>
cd ~
git clone git://github.com/elixir-lang/elixir.git
cd elixir
git checkout v0.8.1
make
cat "$PATH=$PATH:$HOME/elixir/bin" >> ~/.zshrc
          </code></pre>
          <p>OS X</p>
          <pre><code class='bash'>
brew install elixir
          </code></pre>
        </section>
        <section>
          <h3>Install Rebar</h3>
          <p>Erlang build tool, for erlang library dependencies</p>
          <pre><code class='bash'>
# Assumes ~/bin is in your path
cd ~/bin
wget http://cloud.github.com/downloads/basho/rebar/rebar
chmod u+x rebar
          </code></pre>
        </section>
      </section>
-->
      <!-- Erlang -->
      <section>
        <h2>What is Erlang?</h2>
        <div class="fragment">
          <blockquote>
            a general-purpose programming language and runtime environment. Erlang has built-in support for concurrency, distribution and fault tolerance.
          </blockquote>
          <p class='attribution'><a href='http://www.erlang.org/faq/introduction.html'>erlang.org</a></p>
        </div>
        <div class="fragment">
          <blockquote>Erlang is a concurrent language which is used to develop naturally clustered large scale applications. This is one of the only languages today that has been designed to get massive.</blockquote>
          <p class='attribution'>Mickaël Rémond @ <a href="http://blog.process-one.net/web_20_shifting_from_get_fast_to_get_massive/">process-one.net</a></p>
        </div>
      </section>

      <section>
        <!-- do i want this? -->
        <h2>Erlang's design decisions</h2>
        <br/>
        <p class="fragment">a <strong>functional</strong> language (no objects!)</p>
        <p class="fragment">a language designed in 1986 to solve specific telecom challenges</p>
        <p class="fragment">ideal for implementing applications that require <strong>high concurrency</strong></p>
        <p class="fragment">ideal for implementing <strong>highly available/fault tolerant systems</strong></p>
        <p class="fragment">great for writing <strong>distributed</strong> applications (on Erlang clusters)</p>
        <p class="fragment">has to "run forever" - hot code swapping, hot upgrades, high availability, process supervisors with failure handling and recovery policies</p>
      </section>

      <section>
        <h2>Fault tolerant means at least two servers</h2>
        <p>Hardware fails, don't depend that it does not</p>
      </section>
      <section>
        <h2>Fault tolerant means <strong>your</strong> application can fail too!</h2>
        <p class="fragment"><strong>Failures WILL happen</strong>, design to handle them</p>
        <p class="fragment">Limit the blast radius of potential failures by design</p>
        <p class="fragment">Erlang comes with <strong>OTP framework</strong> to help you do that and more!</p>
      </section>

      <section>
        <h2>Erlang is <strong>functional</strong></h2>
      </section>

      <section>
        <h2>Erlang</h2>
        <ul>
        <li class="fragment">is <strong>byte compiled</strong> to BEAM and run on ErlangVM (EVM), similar to Java code on JVM</li>
        <li class="fragment"><strong>shares nothing</strong> between
        processes</li>
        <li class="fragment">data types are <strong>immutable</strong></li>
        <li class="fragment">is using <strong>all the cores</strong> on the machine it runs on (and is NUMA aware)</li>
        <li class="fragment">is capable of running applications seamlessly across (up to hundreds of) physical servers</li>
        <li class="fragment">is able to spawn <strong>hundreds of thousands of processes</strong> on a single server</li>
        <li class="fragment">is <strong>preemptive scheduling</strong>
        between Erlang's micro-processes (no need to yield etc.) each
        process gets a share of CPU time</li>
        <li class="fragment">applications/servers don't need to be
        stopped for upgrades thanks to <strong>hot code swapping</strong></li>
        <li class="fragment">has built in error recovery support</li>
        <li class="fragment">is around for <strong>25+ years</strong> - very mature, industry proven, comes with lots of tools and frameworks</li>
        <li class="fragment">can run on tiny, low power devices as
        well as on latest and most powerful servers</li>
        <li class="fragment">can be extended with other programming
        languages (C/C++, Java, Python, Ruby etc)</li>
        </ul>
      </section>
      <section>
        <h2>Erlang Processes</h2>
        <ul>
          <li class="fragment">very <strong>lightweight</strong> -
          newly spawned process is just over 300 words - word is 4 (32bit) or 8 (64bit) bytes</li>
          <li class="fragment">behind the scenes they are just function code (stack) and some data (heap)</li>
          <li class="fragment">you can spawn a lot of them - there's a benchmark spawning 20mil processes</li>
          <li class="fragment">efficient <strong>per process garbage collection</strong></li>
          <li class="fragment">processes communicate via <strong>async messages</strong></li>
          <li class="fragment">sending messages is very cheap</li>
          <li class="fragment">processes behave same way on different hardware architectures</li>
          <li class="fragment">processes <strong>can monitor each
          other</strong></li>
          <li class="fragment">processes <strong>can be linked
          together</strong> for process termination propagation</li>
          <li class="fragment">remote processes appear and communicate
          same way as local</li>
          <li class="fragment">can <strong>register names</strong> locally (same node)
          or globally (on whole cluster) and be accessed by their name</li>
        </ul>
      </section>
      <section>
        <section>
          <h2>Prepare for lightspeed</h2>
          <img src="img/hyperspace_falcon.png" alt="hyperspace"/>
          <p>I'll fly thgough this part so don't worry if you don't catch everything</p>
        </section>

        <section>
          <h2>Some syntax weirdness</h2>
          <p class="fragment">Periods <strong>.</strong> end everything except when</p>
          <p class="fragment">Semicolons <strong>;</strong> end clauses</p>
          <p class="fragment">and Commas <strong>,</strong> separate expressions</p>
        </section>

        <section>
          <h2>Single assignment variables</h2>
          <pre><code class="erlang" data-noescape>~> erl
Erlang R16B01 (erts-5.10.2) [source] [64-bit] [smp:8:8] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]

Eshell V5.10.2  (abort with ^G)
1> <span class="fragment">A = 1.   % variables must start with capital letter
1
2> </span><span class="fragment">B = (2 * A) + 3.    
5
3> </span><span class="fragment">B = 3.    % once assigned, they cannot change!
** exception error: no match of right hand side value 3
4> </span>
          </pre></code>
        </section>
              
        <section>
          <img src="img/raised_eyebrow.png"/>
          <p>Wot?</p>
        </section>
        
        <section>
          <p>There are <strong>no</strong> loops (while, for, etc)</p>
          <p>Use <strong>recursive functions</strong> instead</p>
          <img src="img/photobucket-shocked.gif" class="fragment" />
        </section>
        <section>
          <h2>Strings</h2>
          <pre><code class="erlang" data-noescape>1> <span class="fragment">MyStr = "abcd".
"abcd"
2> </span><span class="fragment">MyStr = [97, 98, 99, 100].  % wait.. what?!
"abcd"
3> </span><span class="fragment">lists:sort("dcba").  % because they are lists we can do things like this
"abcd"
4> </span>
          </code></pre>
          <p class="fragment">Strings are just lists</p>
        </section>
        
        <section>
          <h2>Some cool things</h2>
        </section>
        
        
          </code></pre>
        </section>
       <!--  
        <section>
          <h2>Numbers</h2>
          <p>As large as memory permits</p>
          <pre><code class="erlang" data-noescape>1> <span class="fragment">1 + 1.
2
2> </span><span class="fragment">1 + 2.0.
3.0
3> </span><span class="fragment">1/2.
0.5
4> </span><span class="fragment">0 == 0.0.    % '==' means 'is like'
true
5> </span><span class="fragment">1 =:= 1.0.   %  '=:=' means 'exactly as'
false
6> </span><span class="fragment">0 = 0.
0
7></span>
          </code></pre>
        </section>
-->
       <!-- 
        <section>
          <h2>(Linked) Lists</h2>
          <pre><code class="erlang" data-noescape>1> <span class="fragment">List = [1, 2, 3].
[1,2,3]
2> </span><span class="fragment">[Head | Tail] = List.
[1,2,3]
3> </span><span class="fragment">Head.
1
4> </span><span class="fragment">Tail.
[2,3]
5> </span><span class="fragment">lists:nth(2, List).
2
6> </span><span class="fragment">lists:sort(List).
[1,2,3]
7> </span><span class="fragment">lists:member(1, List).
true
8> </span><span class="fragment">List ++ [4,5].
[1,2,3,4,5]
9> </span><span class="fragment">[0 | List].
[0,1,2,3]
10> </span><span class="fragment">[1, 2, 3, {numbers,[4,5,6]}, 5.34, atom].
[1, 2, 3, {numbers,[4,5,6]}, 5.34, atom]</span>
          </code></pre>
        </section>
        -->
       
        <section>
          <h2>List comprehension</h2>
          <pre><code class="erlang" data-noescape>1><span class="fragment">[2*N || N <- [1,2,3,4]].   % list comperhension!
[2,4,6,8]
2> </span><span class="fragment">[X || X <- [1,2,3,4,5,6,7,8,9,10], X rem 2 =:= 0].
[2,4,6,8,10]
3> </span><span class="fragment">[X+Y || X <- [1,2], Y <- [2,3]].
[3,4,4,5]
4> </span><span class="fragment">Weather = [{toronto, rain}, {montreal, storms}, {london, fog},  
4>            {paris, sun}, {boston, fog}, {vancouver, snow}].
[{toronto,rain},
{montreal,storms},
{london,fog},
{paris,sun},
{boston,fog},
{vancouver,snow}]
5> </span><span class="fragment">FoggyPlaces = [X || {X, fog} <- Weather].  % pattern matching in list comperhension!
[london,boston]</span>
          </code></pre>
        </section>

        <section> 
          <h2>Binaries and Bit Syntax</h2>
          <pre><code class="fragment" data-noescape>
1> <span class="fragment">Color = 16#F09A29.
15768105
2> </span><span class="fragment">Pixel = << Color:24 >>.
<< 240,154,41 >>
3> </span><span class="fragment"><< R:8, G:8, B:8 >> = << Color:24 >>.
<< 240,154,41 >>
7> </span><span class="fragment">R.
240
8> </span><span class="fragment"><< R:8, Rest/binary >> = Color.
<< 240,154,41 >>
9> </span><span class="fragment">R.
240
10> </span><span class="fragment"><< SourcePort:16, DestinationPort:16,
AckNumber:32,
DataOffset:4, _Reserved:4, Flags:8, WindowSize:16,
CheckSum: 16, UrgentPointer:16,
Payload/binary >> = SomePacket.</span>
          </code></pre>
        </section>

        <section>
          <h2>Binary comprehension</h2>
          <pre><code class="erlang" data-noescape>
1> <span class="fragment">[ X || << X >> <= << 1,2,3,4,5 >>, X rem 2 == 0].    
[2,4]
2> </span><span class="fragment">Pixels = << 213,45,132,64,76,32,76,0,0,234,32,15 >>.
<< 213,45,132,64,76,32,76,0,0,234,32,15 >>
3> </span><span class="fragment">RGB = [ {R,G,B} || << R:8,G:8,B:8 >> <= Pixels ].
[{213,45,132},{64,76,32},{76,0,0},{234,32,15}]
4> </span><span class="fragment"><< << R:8, G:8, B:8 >> ||  {R,G,B} <- RGB >>.
<< 213,45,132,64,76,32,76,0,0,234,32,15 >>
</span>
          </code></pre>
        </section>
        
        <section>
          <h2>Atoms</h2>
          <p>Similar to Ruby symbols, used to represent non-numerical constants, ie. true, ok, blah, error</p>
          <pre><code class="erlang" data-noescape>
1> ok.
ok
2> error.
error
3> true.
true
4> A = false.
false
5> A.
false
6> {ok, "success"}.
{ok,"success"}
7>
          </code></pre>
        </section>

        <section>
          <h2>Tuples</h2>
          <p>Fixed length collection of items - the workhorse of
          Erlang</p>
          <pre><code class="erlang" data-noescape>
1> <span class="fragment">X = 10, Y = 4.
4
2> </span><span class="fragment">Point = {X,Y}.
{10,4}
3> </span><span class="fragment">Point = {4,5}.
{4,5}
4> </span><span class="fragment">{X,Y} = Point.
{4,5}
5> </span><span class="fragment">X.
4
6> </span><span class="fragment">{X,_} = Point.
{4,5}
7> </span><span class="fragment">{_,_} = {4,5}.
{4,5}
8> </span><span class="fragment">{_,_} = {4,5,6}.
** exception error: no match of right hand side value {4,5,6}
9> </span><span class="fragment">{point, {X,Y}}.
{point,{4,5}}
</span>         </code></pre>
        </section>
<!--
        <section>
          <h2>Proplists, Dicts, etc.</h2>
          <pre><code class="erlang" data-noescape><span class="fragment">
1> proplists:get_value(yellow, [{yellow, bananna}, {red, apple}, {yellow, lemon}]).
bananna
2> </span><span class="fragment">proplists:lookup(yellow, [{yellow, bananna}, {red, apple}, {yellow,lemon}]).
{yellow,bananna}
3> </span><span class="fragment">proplists:delete(yellow, [{yellow, bananna}, {red, apple}, {yellow,lemon}]).
[{red,apple}]
4> </span><span class="fragment">proplists:get_all_values(yellow, [{yellow, bananna}, {red, apple},{yellow, lemon}]).
[bananna,lemon]
5> </span><span class="fragment">D = dict:new().
{dict,0,16,16,8,80,48,
      {[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]},
      {{[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]}}}
6> </span><span class="fragment">D1 = dict:store(yellow, bananna, D).
7> </span><span class="fragment">D1:find(yellow).
{ok,bananna}
8> </span><span class="fragment">dict:find(yellow, D1).
{ok,bananna}
9> </span><span class="fragment">dict:fetch(yellow, D1).
bananna
10> </span><span class="fragment">S = sets:new().
{set,0,16,16,8,80,48,
     {[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]},
     {{[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]}}}
11> </span><span class="fragment">sets:to_list( sets:intersection(sets:from_list([1,2,3,4]),
sets:from_list([3,4,5,6,7])) ).
[3,4]
12> </span>

          </pre></code>
        </section>
-->
        <section>
          <h2>Other data types</h2>
          <ul>            
            <li class="fragment"><strong>proplist</strong> - property list</li>
            <li class="fragment"><strong>dict</strong> - dictionary/hash table</li>
            <li class="fragment"><strong>orddict</strong> - ordered dictionary</li>
            <li class="fragment"><strong>gb_trees</strong> - general balanced
            trees</li>
            <li class="fragment"><strong>ordsets</strong> - ordered sets</li>
            <li class="fragment"><strong>gb_sets</strong> - general balanced sets</li>
            <li class="fragment"><strong>sofs</strong> - sets of sets</li>
            <li class="fragment"><strong>digraph</strong> - directed graphs</li>
            <li class="fragment"><strong>queue</strong> - all kind of queue
            implementations</li>
          </ul>
        </section>
        
        <section>
          <h2>Functions and pattern matching</h2>
          <pre><code class="erlang" data-noescape><span class="fragment">
calculate_area({square, Size}) ->
  Size * Size;
</span><span class="fragment">
calculate_area({rect, A, A}) ->
  calculate_area({square, A});
</span><span class="fragment">
calculate_area({rect, A, B}) when is_integer(A), is_integer(B) ->
  A * B;
</span><span class="fragment">
calculate_area({circle, Radius}) Radius > 0, is_integer(Radius) ->
  Pi = 3.14,
  Pi * Radius * Radius;
</span><span class="fragment">
calculate_area(_Unknown) ->
  unknown.
</span>
          </code></pre>
        </section>  

        <section>
          <h2>Anonymous functions</h2>
          <pre><code class="erlang" data-noescape><span class="fragment">
lists:map(fun(X) -> X * X end, List).
</span><span class="fragment">
% or

F = fun(X) ->
  X * X
end.

lists:map(F, List).
          </span></code></pre>
        </section>

        <section>
          <h2>Modules</h2>
          <pre class="left">useless.erl</pre>

          <pre><code class="erlang" data-noescape>
-module(useless). <span class="fragment"> % module declaration, has to match the name of the file</span>
-export([add/2, hello/0, hello/1, greet_and_add_two/1]).<span class="fragment">  % declare which functions to export
% this is a list of function names and their arity (number of arguments)</span>
 
add(A, B) ->
  A + B.
 
<span class="fragment">%% Shows greetings.
%% io:format/1 is the standard function used to output text.</span>
hello() ->
  io:format("Hello, world!~n"). <span class="fragment"> % this is the only definition of hello/0 so we finish it with a dot</span>

hello({name, Name}) ->
  io:format("Hello there, ~n!", [Name]);   <span class="fragment"> % we are not finished yet with defining hello/1</span>

hello(Other) ->
  io:format("Hey, ~n whatever you are!", [Other]). <span class="fragment"> % this is last definition of hello/1</span>
 
greet_and_add_two(X) ->
  hello(),
  hello({name, "Bob"}),
  hello("Thing"),
  add(X, 2).
          </code></pre>
        </section>

        <section>
          <h2>Conditionals</h2>
          <pre><code class="erlang" data-noescape>
case Expression of <span class="fragment">
  {run_command, Cmd} ->
    do_something(Cmd);</span><span class="fragment">
  _ ->  % anything starting with underscore means 'ignore this' or 'anything'
    ok</span>
end.
          </span></code></pre>
        </section>

        <section>
          <h2>Tail recursion</h2>
          <pre><code class="erlang" data-noescape>
print_each([]) ->  
  ok;

print_each([H|T]) ->
  io:format("~p~n", [H]),
  print_each(T).   % tail recursion is safe - does not build up stack
          </code></pre>
        </section>
        <section>
          <h2>Spawning new process</h2>
          <pre><code class="erlang" data-noescape>
F = fun() ->
  io:format("Hi")
end.

Pid = spawn(F).
            </code></pre>
            or
            <pre><code class="erlang" data-noescape>
Pid = spawn(io, format, ["Hi"]).  % spawn(Module, Function, Args)

Pid = spawn('node1@somehost', io, format, ["Hi"]).  % spawn(Node, Module, Function, Args)
            </code></pre>
        </section>

        <section>
            <h2>Message passing</h2>
            <div class="side-by-side">
                <pre class="left fragment"><code class="erlang" data-noescape>Pid ! Message.

Pid ! {run_command, shutdown}.

Pid ! 42.


                </code></pre>
                <pre class="right fragment"><code class="erlang" data-noescape>receive
  {run_command, Cmd} ->
    io:format("Running command ~p~n", [Cmd]);
  Data when is_integer(Data) ->
    io:format("Got a number ~p~n", [Data]);
  Data ->
    io:format("Got something ~p~n", [Data])
end.
</code></pre>
            </div>
            <span class="fragment"><strong>Pid</strong> can exist on <strong>any node</strong> (server) of Erlang cluster!</span>
        </section>
<!-- 
        <section>
          <h2>Records</h2>
          <div class="side-by-side">
          
          <pre class="left"><code class="erlang" data-noescape>-module(records).
-compile(export_all).  % export all functions
 
-record(robot, {name,
  type=industrial,
  hobbies,
  details=[]}).

first_robot() ->
  #robot{name="Mechatron",
    type=handmade,
    details=["Moved by a small man inside"]}.
<span class="fragment" data-fragment-index=5>
car_factory(CorpName) ->
  #robot{name=CorpName, hobbies="building cars"}.

</span></code></pre>
          <pre class="right"><code class="erlang" data-noescape>1> <span class="fragment" data-fragment-index=1>c(records).
{ok,records}
2> </span><span class="fragment" data-fragment-index=2>records:first_robot().
{robot,"Mechatron",handmade,undefined,
["Moved by a small man inside"]}
3> </span><span class="fragment" data-fragment-index=3>rr(records).
[robot]
4> </span><span class="fragment" data-fragment-index=4>4records:first_robot().        
#robot{name = "Mechatron",type = handmade,
hobbies = undefined,
details = ["Moved by a small man inside"]}
5> </span><span class="fragment" data-fragment-index=6>c(records).
{ok,records}
6> </span><span class="fragment" data-fragment-index=7>records:car_factory("Jokeswagen").
#robot{name = "Jokeswagen",type = industrial,
hobbies = "building cars",details = []}</span></code></pre>
          </div>
        </section>
      </section>

-->
        <!-- Erlang Chat Server -->
        <section>
      
          <section>
            <h2>Let's implement a Chat Server</h2>
            <p></p>
          </section>
          <section>
            <img src="img/rollercoaster.png"/>
            <p>Ready?</p>
          </section>
          <section>
            <pre class="left">my_server.erl</pre>
            <div class="side-by-side">
            <pre class="left"><code class="erlang" data-noescape><span class="fragment">-module(my_server).
-export([listen/2, simple_server/1]).</span><span class="fragment">

-define(TCP_OPTIONS, [binary, {packet, 0}, 
  {active, false}, {reuseaddr, true}]).</span><span class="fragment">

start_registry() ->
  register(socket_mgr, self()),
  registry([]). </span><span class="fragment">

registry(Sockets) -> 
  receive
    {connected, Pid, Socket} -> </span><span class="fragment">
      erlang:monitor(process, Pid), </span><span class="fragment">
      registry([{Pid, Socket}|Sockets]); </span><span class="fragment">
    {'DOWN', _Ref, process, DeadPid, _Reason} -> 
      registry(proplists:delete(DeadPid, Sockets)); </span><span class="fragment">
    {send, Msg} -> </span><span class="fragment">
      lists:map(
        fun({_Pid, Socket}) -> gen_tcp:send(Socket, Msg) end,
        Sockets
      ),</span><span class="fragment">
      registry(Sockets);</span><span class="fragment">
    _ -> registry(Sockets)
  end.


</span></code></pre>
<pre class="right"><code class="erlang" data-noescape><span class="fragment">
send(Msg) ->
  lists:map(
    fun(Node) -> {socket_mgr, Node} ! {send, Msg} end, 
    [node() | nodes()]
  ).</span><span class="fragment">

listen(Port, Handler) ->
  {ok, LSocket} = gen_tcp:listen(Port, ?TCP_OPTIONS), </span><span class="fragment">
  spawn(fun() -> start_registry() end), </span><span class="fragment">
  accept(LSocket, Handler). </span><span class="fragment">

accept(LSocket, Handler) ->
  {ok, Socket} = gen_tcp:accept(LSocket), </span><span class="fragment">
  Pid = spawn(fun() -> Handler(Socket) end), </span><span class="fragment">
  socket_mgr ! {connected, Pid, Socket},</span><span class="fragment">
  accept(LSocket, Handler).</span><span class="fragment">

simple_server(Socket) -></span><span class="fragment">
  case gen_tcp:recv(Socket, 0) of
    {ok, Data} -></span><span class="fragment">
      send(Data),
        simple_server(Socket);</span><span class="fragment">
    {error, closed} -> ok
  end.</span><span class="fragment">
% savvy?

</span></code></pre></div>
          </section>
          <section>
            <img src="img/shocked.png" />
          </section>  
          <section>
            <img src="img/lets_see_what_happens.jpg"/>
            <p>Let's see how this works</p>
          </section>
          <section>
            <div class="side-by-side">
              <pre class="left">Erlang</pre><pre class="right">Shell</pre>
              <pre class="left"><code class="erlang" data-noescape>
> <span class="fragment" data-fragment-index=1>erl -sname b1
Erlang R16B01 (erts-5.10.2) [source] [64-bit] [smp:8:8] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]

Eshell V5.10.2  (abort with ^G)
(b1@bart-mbp)1> </span><span class="fragment" data-fragment-index=2>c(my_server).
{ok,my_server}
(b1@bart-mbp)2> </span><span class="fragment" data-fragment-index=3>my_server:listen(8888, 
    fun(Sock) -> my_server:simple_server(Sock) end).</span>


 


              </code></pre>
              <pre class="right"><code data-noescape>
> <span class="fragment" data-fragment-index=4>telnet localhost 8888
Trying ::1...
telnet: connect to address ::1: Connection refused
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
</span><span class="fragment" data-fragment-index=11>blah
</span><span class="fragment" data-fragment-index=12>blah
</span><span class="fragment" data-fragment-index=14>hey there :)
</span><span class="fragment" data-fragment-index=15>how ya doin?
</span><span class="fragment" data-fragment-index=16>how ya doin?
</span>

              </code></pre>
              <br class="clearfix"/>
              <pre class="left"><code class="erlang" data-noescape>
> <span class="fragment" data-fragment-index=5>erl -sname b2
Erlang R16B01 (erts-5.10.2) [source] [64-bit] [smp:8:8] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]

Eshell V5.10.2  (abort with ^G)
(b2@bart-mbp)1> </span><span class="fragment" data-fragment-index=6>nodes().
[]
(b2@bart-mbp)2> </span><span class="fragment" data-fragment-index=7>net_adm:ping('b1@bart-mbp').
pong
(b2@bart-mbp)3> </span><span class="fragment" data-fragment-index=8>nodes().
['b1@bart-mbp']
(b2@bart-mbp)4> </span><span class="fragment" data-fragment-index=9>my_server:listen(8887, 
  fun(Sock) -> my_server:simple_server(Sock) end).</span>
              </code></pre>
              <pre class="right"><code data-noescape>
> <span class="fragment" data-fragment-index=10>telnet localhost 8887
Trying ::1...
telnet: connect to address ::1: Connection refused
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
</span><span class="fragment" data-fragment-index=12>blah
</span><span class="fragment" data-fragment-index=13>hey there :)
</span><span class="fragment" data-fragment-index=14>hey there :)
</span><span class="fragment" data-fragment-index=16>how ya doin?
</span>

              </code></pre>
            </div>  
          </section>
        </section>  
      

      <!-- Elixir -->
      <section>
        <h2>What is Elixir?</h2>
        <div class="fragment">
          <blockquote>
            Elixir is a functional meta-programming aware language built on top of the Erlang VM. It is a dynamic language with flexible syntax with macros support that leverages Erlang's abilities to build concurrent, distributed, fault-tolerant applications with hot code upgrades.
          </blockquote>
          <p class='attribution'>Jose Valim @ <a href='http://elixir-lang.com'>elixir-lang.com</a></p>
        </div>
      </section>

      <section>
        <section>
          <h2>Influences</h2>
        </section>

        <section>
          <h3>Erlang</h3>
          <ul>
            <li>Compiles to Erlang Bytecode</li>
            <li>Actor Model</li>
            <li>Message Passing, OTP</li>
            <li>Pattern matching</li>
            <li>Guards</li>
            <li>Hot code swapping</li>
          </ul>
        </section>

        <section>
          <h3>Ruby</h3>
          <ul>
            <li>Syntax</li>
            <li>Dependency management</li>
          </ul>
          <aside class='notes'>
            Jose Valim - Rails core contributor
          </aside>
        </section>

        <section>
          <h3>Clojure/Lisp</h3>
          <ul>
            <li>Macros</li>
            <li>Leiningen build tool</li>
            <li>Protocols</li>
            <li>Includes/Imports/Refers</li>
          </ul>
          <aside class='notes'>
            not going to get into macros, protocols, etc - Check out the documentation.
          </aside>
        </section>
      </section>

      <section>
        <section>
          <h2>Elixir at a glance</h2>
          <pre><code class="ruby" data-noescape>defmodule Math do
  def sum(a, b) do
    do_sum(a, b)
  end

  defp do_sum(a, b) do
    a + b
  end

  def zero?(0) do
    true
  end

  def zero?(x) when is_number(x) do
    false
  end
end

Math.sum(1, 2)    #=> 3
Math.do_sum(1, 2) #=> ** (UndefinedFunctionError)
Math.zero?(0)  #=> true
Math.zero?(1)  #=> false
Math.zero?([1,2,3])  #=> ** (FunctionClauseError)

          </pre></code>
        </section>

        <section>
          <h2>Comprehension</h2>
          <pre><code class="ruby" data-noescape>
iex> lc n inlist [1,2,3,4], do: n * 2
[2,4,6,8]

# or using block
iex> lc n inlist [1,2,3,4] do
...>  n * 2
...> end
[2,4,6,8]

iex> lc x inlist [1,2], y inlist [2,3], do: x*y
[2,3,4,6]

iex> lc n inlist [1,2,3,4,5,6], rem(n, 2) == 0, do: n
[2,4,6]
          </pre></code>
        </section>
        <section>
          <h2>Strings</h2>
          <pre><code class="ruby" data-noescape>
iex> "hello" == 'hello'
false
iex> is_binary "hello"
true
iex> is_list 'hello'
true
iex> string = "é"  # unicode support!
"é"
iex> size(string)
2
iex> name = "world"
iex> "hello #{name}"   # string interpolation!
"hello world"


          </pre></code>
        </section>

        <section>
          <h2>Blocks</h2>
          <pre><code class="ruby" data-noescape>
iex> if true do
...>   a = 1 + 2
...>   a + 10
...> end
13

iex> if true, do: (
...>   a = 1 + 2
...>   a + 10
...> )
13

          </pre></code>
        </section>

        <section>
          <h2>Control flow</h2>
          <pre><code class="ruby" data-noescape>case { 1, 2, 3 } do
  { 4, 5, 6 } ->
    "This won't match"
  { 1, x, 3 } ->
    "This will match and assign x to 2"
  _ ->
    "This will match any value"
end

unless true do
  "This will never be seen"
end

if false, do: 1 + 2, else: 10 + 3

if false do
  1 + 2
else
  10 + 3
end

cond do
  2 + 2 == 5 ->
    "This will never match"
  2 * 2 == 3 ->
    "Nor this"
  true ->
    "This will always match (equivalent to else)"
end

          </pre></code>
        </section>
        <section>
          <h2>Calling Erlang</h2>
          <pre><code class="ruby" data-noescape>
iex> :lists.flatten [1,[2],3]
[1,2,3]
iex> :math.sin :math.pi
1.2246467991473532e-16

          </pre></code>
        </section>

        <section>
          <h2>Functions</h2>
          <pre><code class="ruby" data-noescape>
f = fn
  x, y when x > 0 -> x + y
  x, y -> x * y
end

f.(1, 3)  #=> 4
f.(-1, 3) #=> -3

          </pre></code>
        </section>

        <section>
          <h2>Protocols</h2>
          <pre><code class="ruby" data-noescape>defprotocol Blank do
  @doc "Returns true if data is considered blank/empty"
  @only [Atom, List, BitString, Any]
  def blank?(data)
end

defimpl Blank, for: BitString do
  def blank?(""), do: true
  def blank?(_), do: false
end

defimpl Blank, for: List do
  def blank?([]), do: true
  def blank?(_),  do: false
end

# Just the atoms false and nil are blank
defimpl Blank, for: Atom do
  def blank?(false), do: true
  def blank?(nil),   do: true
  def blank?(_),     do: false
end

# anything else is not blank
defimpl Blank, for: Any do
  def blank?(_), do: false
end

Blank.blank?(0)       #=> false
Blank.blank?([])      #=> true
Blank.blank?([1,2,3]) #=> false
          </pre></code>
        </section>
        <section>
          <h2>Processes and Messaging</h2>
          <pre><code class="ruby" data-noescape>
# Get the current process id
iex> current_pid = self()

# Spawn another process that will send a message to current_pid
iex> spawn fn ->
  current_pid <- { :hello, self() }
end
<0.36.0>

# Collect the message
iex> receive do
...>   { :hello, pid } ->
...>     IO.puts "Hello from #{inspect(pid)}"
...> after
...>   1000 -> # 1 second
...>     IO.puts "Too late"
...> end
Hello from <0.36.0>                  
          </pre></code>
        </section>
      </section>

      <!-- Elixir Chat Server -->
      <section>
        <section>
          <h2>Elixir Chat Server</h2>
        </section>
      </section>


      <!-- OTP -->
      <section>
        <section>
          <h2>Oh, the OTP</h2>
          <p>Framework that makes all the difference</p>
        </section>
        <section>
          <h2>What is OTP?</h2>
          <p class="fragment">formalizes structure for applications</p>
          <p class="fragment">provides behaviours - callback templates
          (design patterns) for your code</p>
        </section>
        <section>
          <h2>Applications, Supervisors and Workers</h2>
          <ul>
            <li class="fragment"><strong>application</strong> -
            defines how application is implemented</li>
            <li class="fragment"><strong>supervisor</strong> - defines
            supervisor trees, restart strategies and workers</li>
            <li class="fragment"><strong>gen_server</strong> -
            behaviour for server type workers</li>
            <li class="fragment"><strong>gen_fsm</strong> - behaviour
            for creating finite state machines</li>
            <li class="fragment"><strong>gen_event</strong> -
            behaviour for creating event handlers</li>
          </ul>
        </section>
        <section>
          <h2>Application</h2>
          <img src="img/application-controller.png"/>
          <p style="font-size:40%">image
          from <a href="http://learnyousomeerlang.com/">LearnYouSomeErlang.com</a></p>
            <p class="fragment">contains list of modules and arguments in your
            application</p>
            <p class="fragment">is responsible for starting and stopping
            supervisor(s) your application needs</p>

        </section>

        <section>
          <h2>Supervisor</h2>
          <img src="img/sup-tree.png" />
          <p style="font-size:40%">image
          from <a href="http://learnyousomeerlang.com/">LearnYouSomeErlang.com</a></p>
          <p class="fragment">responsible for starting and maintaining
          workers and other supervisors</p>
          <p class="fragment">defines restart strategy for processes -
          it's the heart of the robustness of Erlang applications!</li>
        </section>
        
        <section>
          <h2>Generic Server gen_server</h2>
          <p class="fragment">a template for client/server application workers</p>
          <p class="fragment">you may think of it as abstract
          class</p>
          <p class="fragment">your code is a collection of callbacks
          - the process is managed by OTP</p>
          <p class="fragment">you can implement sync and async calls
          with handle_call and handle_cast callbacks</p>
        </section>
        <section>
          <h2>Finite State Machine gen_fsm</h2>
          <img src="img/fsm_dog.png" />
          <p style="font-size:40%">image
          from <a href="http://learnyousomeerlang.com/">LearnYouSomeErlang.com</a></p>
          <p class="fragment">behaviour for defining FSM</p>
        </section>
        <section>
          <h2>Events gen_event</h2>
          <img src="img/event-manager.png" />
          <p style="font-size:40%">image
          from <a href="http://learnyousomeerlang.com/">LearnYouSomeErlang.com</a></p>
          <p class="fragment">behaviour for custom event handlers</p>
          <p class="fragment">used to implement efficient message
          dispatching between processes</p>

          <p class="fragment">If your server has many subscribers, it can keep going
              because it only needs to forward events once</p>       
          <p class="fragment">You don't need to spawn processes for short lived tasks</p>
          
          
        </section>
        
        <section>
          <section>
            <h2>OTP in Erlang</h2>
          </section>  
        </section>
        <section>
          <section>
            <h2>OTP in Elixir</h2>
          </section>
        </section>

      </section>

      
      <!-- Tools -->
      <section>
        <section>
          <h2>Testing</h2>
        </section>
        <section>
          <h2>Building</h2>
        </section>
      </section>

      <!-- What is erlang good for? Who is using it? -->
      <section>
        <h2>Who is using Erlang?</h2>
        <p class="fragment">Ericsson - AXD 301, GPRS, LCS</p>
        <p class="fragment">Erlang Financial Systems - Banking &amp; Lottery systems<p>
        <p class="fragment">Nortel - VPN gateway + others<p>
        <p class="fragment">Facebook - Messenger chat<p>
        <p class="fragment">Google - GTalk<p>
        <p class="fragment">Amazon - SQS and SimpleDB<p>
        <p class="fragment">Microsoft - Bing search<p>
        <p class="fragment">EMC/VMWare - RabbitMQ<p>
        <p class="fragment">MochiMedia - Flash ads middleware<p>
        <p class="fragment">Del.icio.us/Yahoo - social bookmarking<p>
        <p class="fragment">AOL</p>
        
      </section>  

      <!-- Brief look at other tools (dialyzer, zotonic, wrangler, meck, proper, cover, ChicagoBoss, Cowboy -->

      <!-- Links -->
      <section>
        <h2>Links</h2>
        <p>erlang</p>
        <p>elixir</p>
        <p>Learn You Some Erlang</p>

      </section>

      <section>
        <h2>Things I didn't talk about</h2>
        <p>ETS/DETS</p>
        <p>Mnesia</p>
        <p>Elixir macros</p>
        <p>exception handling</p>
      </section>

      <!-- Thanks -->
      <section>
        <h2>Questions?</h2>
        <p>Thanks!</p>
        <p></p>
        <p>Bart Ptaszynski <a href="http://twitter.com/foobarto">@foobarto</a> | <a href="mailto:bart@yazzgoth.com">bart@yazzgoth.com</a></p>
      </section>
    </div>

  </div>

  <script src="js/head.min.js"></script>
  <script src="js/highlight.js"></script>
  <script src="js/reveal.min.js"></script>
  <script src="js/notes.js"></script>

  <script type="text/javascript">

    Reveal.initialize({
      width: '90%',
      height: '100%',
          //center: true,
          progress: true,
          history: true,
          transition: 'linear',
          dependencies: [
            { src: 'js/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
            { src: 'js/notes.js', async: true, condition: function() { return !!document.body.classList; } }
          ]
        });

  </script>

</body>
</html>
